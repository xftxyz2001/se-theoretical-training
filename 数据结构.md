# 第0章 课程安排
总成绩 = 20%平时（考勤+课堂表现） + 20%作业（雨课堂完成每章一个测试卷） + 60%考试（闭卷考试）



# 第1章 绪论

## 本章内容
- 1.1 基本概念
  - 数据，数据对象，数据元素，数据项
  - 数据类型（原子、构造、抽象）
  - 数据结构
- 1.2 数据结构三要素：逻辑结构、物理结构与运算
- 1.3 算法及其评价
  - 算法的定义、特性、设计要求
  - 算法评价：时空复杂度


## 1.1 基本概念
- **数据**：能输入计算机且被处理的各种符号的**集合**。
- **数据元素**：组成数据的基本单位，是数据集合的**个体**。本课程讨论的最小单位。
- **数据对象**：性质相同的数据元素的集合，是数据的一个**子集**。
- **数据结构**：带有某种结构关系的、性质相同的数据元素的集合，包括逻辑关系、物理存储和操作。

数据类型
- **原子类型**：值不可再分的数据类型。如 int,char,double 等。
- **结构类型**：值可以再分解为若干成分的数据类型。如 struct、union 。
- **抽象数据类型ADT**：
  - 数组是什么类型？构造
  - 枚举是什么类型？原子
  - 指针是什么类型？原子

**抽象数据类型**（Abstract Data Type）定了一个数据对象、数据对象中各元素间的结构关系和一组操作。可用一个三元组表示：（数据对象、关系、基本操作）

**抽象是一种思维方式**，抽取问题的本质特征，隐藏了复杂的细节，让使用者**只关注应用**而**不关注实现细节**。

> 哥尼斯堡七桥问题：![1683620980738](image/数据结构/1683620980738.png)
> 欧拉回路条件：
> 1. 图形必须是连通的。
> 2. “奇点”个数是0或2。


## 1.2 数据结构三要素
**逻辑结构**：数据元素间的逻辑关系，分为线性结构和非线性结构（集合、树和图结构）。
![1683621076323](image/数据结构/1683621076323.png)

![1683621098417](image/数据结构/1683621098417.png)

> 数据元素及其关系的物理存储方式分**顺序存储**和**链式存储**。该说法（ ）。
> - A 正确
> - B 错误

**物理结构**：数据元素及其关系在计算机上的映像。
- 顺序：存储地址连续
- 非顺序：
  - 链式：存储地址不一定连续
  - 索引：需要另外建立索引表上非顺序
  - 散列：哈希存储

![1683621416115](image/数据结构/1683621416115.png)

**运算（操作）**：施加在数据对象上的一组运算。基于逻辑结构定义，基于存储结构实现。
![1683621458410](image/数据结构/1683621458410.png)

> 以下属于算法特性的是
> - A 正确性
> - B 可读性
> - C 可行性
> - D 健壮性
> - E 确定性
> - F 有限性


## 1.3 算法特性与性能分析
- **算法定义**：解决特定问题的一系列操作。
  ![1683621611566](image/数据结构/1683621611566.png)
- **算法特性**：输入（$\ge 0$）、输出（$\ge 1$）、确定性、可行性和有限性。
- **算法设计要求**：正确、可读性、健壮性（鲁棒性）、高效低存储。
- **算法描述**：自然语言、伪代码、流程图、高级语言等。

**评价算法优劣的标准——时空复杂度**

时间复杂度 $T(n) = O(f(n))$ ：算法的时间耗费度量，与输入数据的规模有关。表示当 $n$ 逐渐增大时，算法运行的时间耗费增长率与 $f(n)$ 增长率相同。

时间复杂度分析步骤：
1. 找算法中的基本语句（执行频率最高）
2. 计算其执行次数，整理成问题规模 $n$ 的函数 $f(n)$
3. 保留最高次幂，作为（渐进）时间复杂度

$O(1) \lt O(\log n) \lt O(n) \lt O(n\log n) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!) \lt O(n^n)$

![1683621834605](image/数据结构/1683621834605.png)

- 快速排序算法： $T(n) = O(n\log n)$
- Dijkstra算法： $T(n) = O(n^2)$
- 最大团算法： $T(n) = O(n 2^n)$

> 假设某计算机运行速度为10亿次/秒运算，那么
> - 10万个数据排序： $10^5 \times \log 10^5 \div 10^9 \approx 1.7 \times 10^6 \div 10^9 = 1.7ms$
> - 1万个顶点求单源最短路径： $(10^4)^2 \div 10^9 = 0.1s$
> - 100个J顶点求最大团： $100 \times 2^{100} \div 10^9 \approx 1.8 \times 10^{21}s \approx 5.7 \times 10^{15}年$

```c
int i = 0, sum = 0;
while (sum < n)
{
    i++;
    sum += i;
}
```
时间复杂度：
1. 基本语句：while
2. 执行次数：设while循环语句执行次数为m，i从1开始递增，最后取值为m，则：
   - $sum = 1 + 2 + \ldots + m = m(m+1)/2$ ，即 $m(m+1)/2 \le n$
3. $T(n) = O(\sqrt{n})$

```c
void mergesort(int a[], int i, int j)
{
    int m;
    if (i < j)
    {
        m = (i + j) / 2;
        mergesort(a, i, m);
        mergesort(a, m + 1, j);
        merge(a, i, j, m); // O(n)
    }
}
```
递归方程：
$$
\begin{aligned}
T(n) =& 2 T(n/2) + n \\
=& 2[2T(n/2^2) + n/2] + n \\
=& 2^2 T(n/2^2) + 2n \\
=& 2^3 T(n/2^3) + 3n \\
... \\
=& 2^k T(n/2^k) + kn \\
=& nO(1) + n \log n = n + n \log n \\
=& O(n \log n)
\end{aligned}
$$

递归算法时间复杂度分析：
- **替换法**：迭代替换
- **主方法**：利用主定理。设 $a \ge 1, b \gt 1$ 为常数， $T(n) = aT(n / b) + f(n)$ ， 则 $T(n)$ 计算如下：
  - 如果函数 $n^{log_b a}$ 比函数 $f(n)$ 大，则 $T(n) = O(n^{log_b a})$
  - 如果函数 $n^{log_b a}$ 和函数 $f(n)$ 相同，则 $T(n) = O(n^{log_b a} \log n)$
  - 如果函数 $n^{log_b a}$ 比函数 $f(n)$ 小，则 $T(n) = O(f(n))$

> ![1683623195227](image/数据结构/1683623195227.png)

当基本语句执行次数与输入数据的顺序有关时，关注**最坏时间复杂度**。
```c
int Find(int a[], int n, int x)
{
    int i = 0;
    while (i < n) // T(n) = O(n)
    {
        if (a[i] == x)
            break;
        i++;
    }
    return i < n ? i : -1;
}
```

空间复杂度 $S(n) = O(f(n))$ ：算法运行时所占用的存储量，包括形参和临时变量所占空间。在对算法进行存储空间分析时，**只考察临时变量所占空间**。

$S(n)=O(1)$ 的含义：常量空间复杂度，表示算法执行时需要的辅助空间与问题规模无关，也称为算法**原地工作**。
```c
long long Fib(int n)
{
    long long *F = (long long *)malloc(sizeof(long long) * (n + 1)); // S(n)=O(n)
    F[0] = F[1] = 1;
    for (int i = 2; i <= n; i++)
        F[i] = F[i - 1] + F[i - 2];
    return F[n];
}
```

```c
long long Fib(int n)
{
    long x = 1, y = 1, t; // S(n)=O(1)
    for (int i = 2; i <= n; i++)
    {
        t = x;
        x = y;
        y = x + t;
    }
    return y;
}
```

```c
int maxelem(int a[], int i, int j)
{
    int mid = (i + j) / 2, max1, max2; // S(n)=O(n)
    if (i < j)
    {
        max1 = maxelem(a, i, mid);
        max2 = maxelem(a, mid + 1, j);
        return max1 > max2 ? max1 : max2;
    }
    else
    {
        return a[i];
    }
}
```

递归算法空间复杂度 = 每层需要的辅助空间 * 递归深度
```c
typedef int RecordType;
/* r数组中，low到mid单元为一有序序列，mid+1到high为另一有序序列，将二者合并为一个新的有序序列，并放入r数组的low到high单元 */
void Merge(RecordType r[], int low, int mid, int high)
{
    int i, j, k;
    RecordType *A = (RecordType *)malloc(sizeof(RecordType) * (high - low + 1));
    i = low;
    j = mid + 1;
    k = 0;
    while (i <= mid && j <= high)
    {
        if (r[i] <= r[j])
        {
            A[k] = r[i];
            i++;
            k++;
        }
        else
        {
            A[k] = r[j];
            j++;
            k++;
        }
    }
    while (i <= mid)
    {
        A[k] = r[i];
        i++;
        k++;
    }
    while (j <= high)
    {
        A[k] = r[j];
        j++;
        k++;
    }
    for (i = low, k = 0; i <= high; i++, k++)
    {
        r[i] = A[k];
    }
    free(A);
}

void MergeSort(RecordType r[], int low, int high)
{
    int mid;
    if (low < high)
    {
        mid = (low + high) / 2;
        MergeSort(r, low, mid);
        MergeSort(r, mid + 1, high);
        Merge(r, low, mid, high);
    }
}
```
空间复杂度 $S(n)$ ：
- Merge算法中，申请了辅助空间A，该空间的大小为high-low+1。最大时为n，用完即释放。
- 算法递归深度为logn，所以还用了logn的栈空间。
- 因此空间复杂度为 $S(n)=O(n+logn)=O(n)$

> 下面说法：
> - ~~Ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间~~
> - Ⅱ.在相同规模 $n$ 下，复杂度为 $O(n)$ 的算法在时间上总是优于复杂度为 $O(2^n)$ 的算法
> - Ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界
> - Ⅳ.同一个算法，实现语言的级别越高，执行效率越低

算法时间复杂度估算-非递归算法
```c
// T(n) = O(n^{1/2})
void add(int n)
{
    int i = 0, s = 0;
    while (s < n)
    {
        i++;
        s += i;
    }
}
```

```c
// T(n) = O(n \log n)
i = 1;
while (i < n)
{
    for (j = 1; j <= n; j++)
        x += 1;
    i *= 2;
}
```

```c
// T(n) = O(n \log n)
count = 0;
for (k = 1; k <= n; k *= 2)
    for (j = 1; j <= n; j++)
        count++;
```

```c
// T(n) = O(n^{1/2})
int i = 0, sum = 0;
while (sum < n)
    sum += ++i;
return i;
```

```c
// T(n) = O(n)
i = 1;
j = 0;
while (i + j <= n)
    i > j ? j++ : i++;
```

算法时间复杂度估算-递归算法
```c
// T(n) = O(n^2)
void hanoi(int n, char a, char b, char c)
{
    if (n == 1)
    {
        move(a, 1, c);
    }
    else
    {
        hanoi(n - 1, a, c, b);
        move(a, n, c);
        hanoi(n - 1, b, a, c);
    }
}
```

```c
// T(n) = O(n)
void PreOrder(BinTree T)
{
    if (T)
    {
        visit(T);
        PreOrder(T->Left);
        PreOrder(T->Right);
    }
}
```

```c
// T(n) = O(n)
int sum = 0;
for (int i = 1; i < n; i *= 2)
    for (int j = 0; j < i; j++)
        sum++;
```
![1683625533812](image/数据结构/1683625533812.png)

```c
// T(n) = O(n^{1/2}) (n>=0)
while (n >= (x + 1) * (x + 1))
    x++;
```


## 缺失的第一个正数
给定一个含 n（`n>=1`）个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 `{-5, 3, 2, 3}` 中未出现的最小正整数是 1；数组 `{1, 2, 3}` 中未出现的最小正整数是 4。

要求：
1. 给出算法的基本设计思想。
2. 根据设计思想，采用C或C+语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

![1683626360132](image/数据结构/1683626360132.png)
![1683626382412](image/数据结构/1683626382412.png)
![1683626395344](image/数据结构/1683626395344.png)

- [leetcode-41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)



# 第2章 线性表
> 线性结构、线性表、顺序表、链表间有什么区别与联系。
> - 线性结构：一种元素间的逻辑关系
> - 线性表：一种抽象数据类型（存储方式分为顺序表/链表），其元素的逻辑结构为线性结构

> 顺序表是有序表。

## 本章内容
- 2.1 线性表的定义
- 2.2 线性表的顺序存储——顺序表及运算实现
- 2.3 线性表的链式存储——链表及运算实现
  - 单链表
  - 双向链表
  - 循环链表
  - 静态链表*
- 2.4 顺序表和链表综合比较

> 重点考察算法思想且对时空复杂度有要求


## 2.1 线性表的定义
线性表为 $n(n>=0)$ 个**相同数据元素**的**有限序列**，其特点为：
存在唯一首元素、尾元素，除首元素和尾元素外，其余每个元素只有一个前驱和后继（线性结构）。

![1683633202131](image/数据结构/1683633202131.png)


## 2.2 顺序表——线性表的顺序存储
用一段**连续的内存空间**存储线性表中的元素。**逻辑上相邻**的元素，**物理存储**位置**也相邻**。
```c
// 静态分配
#define MAXSIZE 100
typedef struct
{
    ElemType elem[MAXSIZE];
    int last; // 最后元素下标
} SeqList;
```

```c
// 动态分配
typedef struct
{
    Elemtype *pElem;
    int last;
    int maxSize;
} SeqList;
```

顺序表上的基本运算
- 查找： `GetData(L,i); Locate(L,e)`
- 插入：插入位置 $1 \le i \le n+1$ 等概率时，平均移动 $n/2$ 个元素；
- 删除：删除位置 $1 \le i \le n$ 等概率时，平均移动 $(n-1)/2$ 个元素；

顺序表的优缺点：
- 优点：存储密度大（为1）；可随机访问元素。
- 缺点：插入、删除需要移动大量元素；需要连续的内存空间；静态内存分配。

> 存储密度 = 存储元素所占用的总空间 / 存储结构所占用的总空间

> 【例】：线性表采用顺序存储中的动态分配空间。当n个空间已满时，可申请再增加分配m个空间。如果申请失败，说明系统没有（n+m）可分配的连续存储空间。

> 在一个长度为n的顺序表中删除第 $i(1 \le i \le n)$ 个元素时，需向前移动（n-i）个元素。

> 在个元素的线性表的数组表示中，时间复杂度为 $O(1)$ 的操作：
> - Ⅰ.访问第 $i(1 \le i \le n)$ 个结点和求第 $i(2 \le i \le n)$个结，点的直接前驱
> - Ⅱ.在最后一个结，点后插入一个新的结点
> - ~~Ⅲ.删除第1个结点~~
> - ~~Ⅳ.在第 $i(1 \le i \le n)$ 个结点后插入一个结点~~

顺序表中的算法设计，可能会涉及到折半查找、快速排序、归并排序以及《算法设计与分析》课程中的一些经典算法。

【例】：有两个非递减有序顺序表LA和LB，编写算法将二者合并为非递增有序顺序表LC。假设LC足够大。
```c
SeqList *mergeAndReverse(SeqList *LA, SeqList *LB)
{
    if (LA == NULL || LB == NULL)
        return NULL;
    SeqList *LC = (SeqList *)malloc(sizeof(SeqList));
    LC->pElem = (Elemtype *)malloc(sizeof(Elemtype) * (LA->last + LB->last + 2));
    LC->last = -1;
    LC->maxSize = LA->last + LB->last + 2;
    int i = LA->last, j = LB->last;
    while (i >= 0 && j >= 0)
        LC->pElem[++LC->last] = LA->pElem[i] >= LB->pElem[j] ? LA->pElem[i--] : LB->pElem[j--];
    while (i >= 0)
        LC->pElem[++LC->last] = LA->pElem[i--];
    while (j >= 0)
        LC->pElem[++LC->last] = LB->pElem[j--];
    return LC;
}
```

【例】：在长度为n的顺序表L中，删除所有值为e的数据元素。要求时间复杂度为 $O(n)$ 、空间复杂度为 $O(1)$ 。
```c
void DeleteItems(SeqList *L, Elemtype e)
{
    if (L == NULL)
        return;
    int k = 0;
    for (int i = 0; i <= L->last; i++)
        if (L->pElem[i] != e)
            L->pElem[k++] = L->pElem[i];
    L->last = k - 1;
}
```
> 一端工作 类似直接插入排序  
> 算法思想：从空序列开始，依次判断每个元素是否为e：若是e，则继续向后判断，若不是e，则将其插入到前面不含e的列表，继续向后判断。直到结束。  
> 不改变原有元素相对先后顺序  

```c
void DeleteItems(SeqList *L, Elemtype e)
{
    if (L == NULL)
        return;
    int i = 0, j = L->last;
    while (i < j)
    {
        while (i < j && L->pElem[i] != e)
            i++;
        while (i < j && L->pElem[j] == e)
            j--;
        if (i < j)
        {
            Elemtype temp = L->pElem[i];
            L->pElem[i] = L->pElem[j];
            L->pElem[j] = temp;
        }
    }
    L->last = j - 1;
}
```
> 两头夹击 类似一趟快速排序  
> 算法思想：从左边找个是e的元素，从右边找一个不是e的元素，将右边不是e的元素移动到左边元素e的位置。直到左右汇合。  
> 会改变原有元素相对顺序  

【例】已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。
```c
void AdjustSqlist(SeqList *L)
{
    if (L == NULL)
        return;
    int i = 0, j = L->last;
    while (i < j)
    {
        while (i < j && L->pElem[i] % 2 != 0)
            i++;
        while (i < j && L->pElem[j] % 2 == 0)
            j--;
        if (i < j)
        {
            Elemtype temp = L->pElem[i];
            L->pElem[i] = L->pElem[j];
            L->pElem[j] = temp;
        }
    }
}
```

【例】：在长度为的有序顺序表L中，删除所有值相等的多余元素，要求保持原有元素的相对位置不变，且时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。
```c
void DeleteRepeatItems(SeqList *L)
{
    if (L == NULL)
        return;
    int i = 0;
    for (int j = 1; j <= L->last; j++)
        if (L->pElem[i] != L->pElem[j])
            L->pElem[++i] = L->pElem[j];
    L->last = i;
}
```
> 算法思想：类似直接插入排序，将第一个元素视为非重复的有序表，然后依次判断后面的元素是否与前面有序表的最后一个元素相同。若相同，则继续向后判断，若不同，则将其插入到前面非重复有序表中。直到结束。

【变形题】：长度为的无序顺序表L存放正整数元素（元素值不大于1000），编写算法，每个元素保留第一次出现的元素，删除重复出现的多余元素，要求时间复杂度为 $O(n)$ 。
```c
void DelrepeatElem(SeqList *L)
{
    if (L == NULL)
        return;
    int *hash = (int *)malloc(sizeof(int) * MAXSIZE);
    memset(hash, 0, sizeof(int) * MAXSIZE);
    int i = 0;
    for (int j = 0; j < L->last; j++)
    {
        if (hash[L->pElem[j]] == 0)
        {
            hash[L->pElem[j]] = 1;
            L->pElem[i++] = L->pElem[j];
        }
    }
    L->last = i - 1;
}
```

【例】顺序表 $L = (a_1, a_2, \ldots, a_n, b_1, b_2, \ldots, b_m)$ ，设计一个算法，将顺序表调整为 $L = (b_1, b_2, \ldots, b_m, a_1, a_2, \ldots, a_n)$ 。
```c
// 反转顺序表[a,b)区间
void Reverse(SeqList *L, int a, int b)
{
    if (L == NULL)
        return;
    for (int i = a; i < (a + b) / 2; i++)
    {
        Elemtype temp = L->pElem[i];
        L->pElem[i] = L->pElem[a + b - 1 - i];
        L->pElem[a + b - 1 - i] = temp;
    }
}

// 转换a1-an ba-bm -> b1-bm a1-an
void ExchangeSqlist(SeqList *L, int n, int m)
{
    if (L == NULL)
        return;
    Reverse(L, 0, n + m); // 反转整个顺序表
    Reverse(L, 0, m); // 反转前m个元素
    Reverse(L, m, n + m); // 反转后n个元素
}
```

【例】求主元素。某顺序表中存放正整数，如果存在一个数，其出现的频率大于50%，则称其为该顺序表的主元素。设计一个算法找出顺序表中的主元素，如果没有则输出-1。要求时间复杂度尽可能低。

算法原理：去掉数组中一个主元素和另一个与主元素不相等的数，剩下的数中，主元素的出现频率仍然大于50%。

算法步骤：
1. 将第一个出现的元素保存到majorNum中，用count记录majorNum出现的次数，初始时令count=1。
2. 如果下一个遇到的元素仍然是majorNum则将count加1，否则将count减1。如果count=0，则将下一个元素保存到majorNum中，并重置count为0。重复该步骤，直至扫描完全部元素。
3. 判断此时的majorNum是否为真正的主元素。统计majorNum出现的次数，并保存到count中，如果count>n/2，则是主元素，否则不是。

代码实现：
```c
int Majority(int A[], int n)
{
    int majorNum = A[0];
    int count = 1;
    for (int i = 1; i < n; i++)
    {
        if (A[i] == majorNum)
            count++;
        else
        {
            if (count > 0)
                count--;
            else
            {
                majorNum = A[i];
                count = 1;
            }
        }
    }
    if (count > 0)
    {
        count = 0;
        for (int i = 0; i < n; i++)
            if (A[i] == majorNum)
                count++;
    }
    return count > n / 2 ? majorNum : -1;
}
```


## 2.3 链表——线性表的非顺序存储


## 2.4 顺序表和链表的优缺点比较
顺序表：
- 优点：无需存储元素间的关系，存储密度大；可随机查找；
- 缺点：若静态分配，则容易造成溢出或空间浪费，若动态分配，需要移动大量元素；插入删除需要移动大量元素。

链表：
- 优点：动态分配；插入删除不需要移动元素。
- 缺点：需要额外空间存储元素间的关系；不能随机查找。

选择合适存储结构，依据如下：
- 线性表长度是否经常变化；
- 各种操作的频率；
- 操作的位置；

