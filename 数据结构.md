# 第0章 课程安排
总成绩 = 20%平时（考勤+课堂表现） + 20%作业（雨课堂完成每章一个测试卷） + 60%考试（闭卷考试）



# 第1章 绪论

## 本章内容
- 1.1 基本概念
  - 数据，数据对象，数据元素，数据项
  - 数据类型（原子、构造、抽象）
  - 数据结构
- 1.2 数据结构三要素：逻辑结构、物理结构与运算
- 1.3 算法及其评价
  - 算法的定义、特性、设计要求
  - 算法评价：时空复杂度


## 1.1 基本概念
- **数据**：能输入计算机且被处理的各种符号的**集合**。
- **数据元素**：组成数据的基本单位，是数据集合的**个体**。本课程讨论的最小单位。
- **数据对象**：性质相同的数据元素的集合，是数据的一个**子集**。
- **数据结构**：带有某种结构关系的、性质相同的数据元素的集合，包括逻辑关系、物理存储和操作。

数据类型
- **原子类型**：值不可再分的数据类型。如 int,char,double 等。
- **结构类型**：值可以再分解为若干成分的数据类型。如 struct、union 。
- **抽象数据类型ADT**：
  - 数组是什么类型？构造
  - 枚举是什么类型？原子
  - 指针是什么类型？原子

**抽象数据类型**（Abstract Data Type）定了一个数据对象、数据对象中各元素间的结构关系和一组操作。可用一个三元组表示：（数据对象、关系、基本操作）

**抽象是一种思维方式**，抽取问题的本质特征，隐藏了复杂的细节，让使用者**只关注应用**而**不关注实现细节**。

> 哥尼斯堡七桥问题：![1683620980738](image/数据结构/1683620980738.png)
> 欧拉回路条件：
> 1. 图形必须是连通的。
> 2. “奇点”个数是0或2。


## 1.2 数据结构三要素
**逻辑结构**：数据元素间的逻辑关系，分为线性结构和非线性结构（集合、树和图结构）。
![1683621076323](image/数据结构/1683621076323.png)

![1683621098417](image/数据结构/1683621098417.png)

> 数据元素及其关系的物理存储方式分**顺序存储**和**链式存储**。该说法（ ）。
> - A 正确
> - B 错误

**物理结构**：数据元素及其关系在计算机上的映像。
- 顺序：存储地址连续
- 非顺序：
  - 链式：存储地址不一定连续
  - 索引：需要另外建立索引表上非顺序
  - 散列：哈希存储

![1683621416115](image/数据结构/1683621416115.png)

**运算（操作）**：施加在数据对象上的一组运算。基于逻辑结构定义，基于存储结构实现。
![1683621458410](image/数据结构/1683621458410.png)

> 以下属于算法特性的是
> - A 正确性
> - B 可读性
> - C 可行性
> - D 健壮性
> - E 确定性
> - F 有限性


## 1.3 算法特性与性能分析
- **算法定义**：解决特定问题的一系列操作。
  ![1683621611566](image/数据结构/1683621611566.png)
- **算法特性**：输入（$\ge 0$）、输出（$\ge 1$）、确定性、可行性和有限性。
- **算法设计要求**：正确、可读性、健壮性（鲁棒性）、高效低存储。
- **算法描述**：自然语言、伪代码、流程图、高级语言等。

**评价算法优劣的标准——时空复杂度**

时间复杂度 $T(n) = O(f(n))$ ：算法的时间耗费度量，与输入数据的规模有关。表示当 $n$ 逐渐增大时，算法运行的时间耗费增长率与 $f(n)$ 增长率相同。

时间复杂度分析步骤：
1. 找算法中的基本语句（执行频率最高）
2. 计算其执行次数，整理成问题规模 $n$ 的函数 $f(n)$
3. 保留最高次幂，作为（渐进）时间复杂度

$O(1) \lt O(\log n) \lt O(n) \lt O(n\log n) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!) \lt O(n^n)$

![1683621834605](image/数据结构/1683621834605.png)

- 快速排序算法： $T(n) = O(n\log n)$
- Dijkstra算法： $T(n) = O(n^2)$
- 最大团算法： $T(n) = O(n 2^n)$

> 假设某计算机运行速度为10亿次/秒运算，那么
> - 10万个数据排序： $10^5 \times \log 10^5 \div 10^9 \approx 1.7 \times 10^6 \div 10^9 = 1.7ms$
> - 1万个顶点求单源最短路径： $(10^4)^2 \div 10^9 = 0.1s$
> - 100个J顶点求最大团： $100 \times 2^{100} \div 10^9 \approx 1.8 \times 10^{21}s \approx 5.7 \times 10^{15}年$

```c
int i = 0, sum = 0;
while (sum < n)
{
    i++;
    sum += i;
}
```
时间复杂度：
1. 基本语句：while
2. 执行次数：设while循环语句执行次数为m，i从1开始递增，最后取值为m，则：
   - $sum = 1 + 2 + \ldots + m = m(m+1)/2$ ，即 $m(m+1)/2 \le n$
3. $T(n) = O(\sqrt{n})$

```c
void mergesort(int a[], int i, int j)
{
    int m;
    if (i < j)
    {
        m = (i + j) / 2;
        mergesort(a, i, m);
        mergesort(a, m + 1, j);
        merge(a, i, j, m); // O(n)
    }
}
```
递归方程：
$$
\begin{aligned}
T(n) =& 2 T(n/2) + n \\
=& 2[2T(n/2^2) + n/2] + n \\
=& 2^2 T(n/2^2) + 2n \\
=& 2^3 T(n/2^3) + 3n \\
... \\
=& 2^k T(n/2^k) + kn \\
=& nO(1) + n \log n = n + n \log n \\
=& O(n \log n)
\end{aligned}
$$

递归算法时间复杂度分析：
- **替换法**：迭代替换
- **主方法**：利用主定理。设 $a \ge 1, b \gt 1$ 为常数， $T(n) = aT(n / b) + f(n)$ ， 则 $T(n)$ 计算如下：
  - 如果函数 $n^{log_b a}$ 比函数 $f(n)$ 大，则 $T(n) = O(n^{log_b a})$
  - 如果函数 $n^{log_b a}$ 和函数 $f(n)$ 相同，则 $T(n) = O(n^{log_b a} \log n)$
  - 如果函数 $n^{log_b a}$ 比函数 $f(n)$ 小，则 $T(n) = O(f(n))$

> ![1683623195227](image/数据结构/1683623195227.png)

当基本语句执行次数与输入数据的顺序有关时，关注**最坏时间复杂度**。
```c
int Find(int a[], int n, int x)
{
    int i = 0;
    while (i < n) // T(n) = O(n)
    {
        if (a[i] == x)
            break;
        i++;
    }
    return i < n ? i : -1;
}
```

空间复杂度 $S(n) = O(f(n))$ ：算法运行时所占用的存储量，包括形参和临时变量所占空间。在对算法进行存储空间分析时，**只考察临时变量所占空间**。

$S(n)=O(1)$ 的含义：常量空间复杂度，表示算法执行时需要的辅助空间与问题规模无关，也称为算法**原地工作**。
```c
long long Fib(int n)
{
    long long *F = (long long *)malloc(sizeof(long long) * (n + 1)); // S(n)=O(n)
    F[0] = F[1] = 1;
    for (int i = 2; i <= n; i++)
        F[i] = F[i - 1] + F[i - 2];
    return F[n];
}
```

```c
long long Fib(int n)
{
    long x = 1, y = 1, t; // S(n)=O(1)
    for (int i = 2; i <= n; i++)
    {
        t = x;
        x = y;
        y = x + t;
    }
    return y;
}
```

```c
int maxelem(int a[], int i, int j)
{
    int mid = (i + j) / 2, max1, max2; // S(n)=O(n)
    if (i < j)
    {
        max1 = maxelem(a, i, mid);
        max2 = maxelem(a, mid + 1, j);
        return max1 > max2 ? max1 : max2;
    }
    else
    {
        return a[i];
    }
}
```

递归算法空间复杂度 = 每层需要的辅助空间 * 递归深度
```c
typedef int RecordType;
/* r数组中，low到mid单元为一有序序列，mid+1到high为另一有序序列，将二者合并为一个新的有序序列，并放入r数组的low到high单元 */
void Merge(RecordType r[], int low, int mid, int high)
{
    int i, j, k;
    RecordType *A = (RecordType *)malloc(sizeof(RecordType) * (high - low + 1));
    i = low;
    j = mid + 1;
    k = 0;
    while (i <= mid && j <= high)
    {
        if (r[i] <= r[j])
        {
            A[k] = r[i];
            i++;
            k++;
        }
        else
        {
            A[k] = r[j];
            j++;
            k++;
        }
    }
    while (i <= mid)
    {
        A[k] = r[i];
        i++;
        k++;
    }
    while (j <= high)
    {
        A[k] = r[j];
        j++;
        k++;
    }
    for (i = low, k = 0; i <= high; i++, k++)
    {
        r[i] = A[k];
    }
    free(A);
}

void MergeSort(RecordType r[], int low, int high)
{
    int mid;
    if (low < high)
    {
        mid = (low + high) / 2;
        MergeSort(r, low, mid);
        MergeSort(r, mid + 1, high);
        Merge(r, low, mid, high);
    }
}
```
空间复杂度 $S(n)$ ：
- Merge算法中，申请了辅助空间A，该空间的大小为high-low+1。最大时为n，用完即释放。
- 算法递归深度为logn，所以还用了logn的栈空间。
- 因此空间复杂度为 $S(n)=O(n+logn)=O(n)$

> 下面说法：
> - ~~Ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间~~
> - Ⅱ.在相同规模 $n$ 下，复杂度为 $O(n)$ 的算法在时间上总是优于复杂度为 $O(2^n)$ 的算法
> - Ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界
> - Ⅳ.同一个算法，实现语言的级别越高，执行效率越低

算法时间复杂度估算-非递归算法
```c
// T(n) = O(n^{1/2})
void add(int n)
{
    int i = 0, s = 0;
    while (s < n)
    {
        i++;
        s += i;
    }
}
```

```c
// T(n) = O(n \log n)
i = 1;
while (i < n)
{
    for (j = 1; j <= n; j++)
        x += 1;
    i *= 2;
}
```

```c
// T(n) = O(n \log n)
count = 0;
for (k = 1; k <= n; k *= 2)
    for (j = 1; j <= n; j++)
        count++;
```

```c
// T(n) = O(n^{1/2})
int i = 0, sum = 0;
while (sum < n)
    sum += ++i;
return i;
```

```c
// T(n) = O(n)
i = 1;
j = 0;
while (i + j <= n)
    i > j ? j++ : i++;
```

算法时间复杂度估算-递归算法
```c
// T(n) = O(n^2)
void hanoi(int n, char a, char b, char c)
{
    if (n == 1)
    {
        move(a, 1, c);
    }
    else
    {
        hanoi(n - 1, a, c, b);
        move(a, n, c);
        hanoi(n - 1, b, a, c);
    }
}
```

```c
// T(n) = O(n)
void PreOrder(BinTree T)
{
    if (T)
    {
        visit(T);
        PreOrder(T->Left);
        PreOrder(T->Right);
    }
}
```

```c
// T(n) = O(n)
int sum = 0;
for (int i = 1; i < n; i *= 2)
    for (int j = 0; j < i; j++)
        sum++;
```
![1683625533812](image/数据结构/1683625533812.png)

```c
// T(n) = O(n^{1/2}) (n>=0)
while (n >= (x + 1) * (x + 1))
    x++;
```


## 缺失的第一个正数
给定一个含 n（`n>=1`）个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 `{-5, 3, 2, 3}` 中未出现的最小正整数是 1；数组 `{1, 2, 3}` 中未出现的最小正整数是 4。

要求：
1. 给出算法的基本设计思想。
2. 根据设计思想，采用C或C+语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

![1683626360132](image/数据结构/1683626360132.png)
![1683626382412](image/数据结构/1683626382412.png)
![1683626395344](image/数据结构/1683626395344.png)

- [leetcode-41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)



# 第2章 线性表
> 线性结构、线性表、顺序表、链表间有什么区别与联系。
> - 线性结构：一种元素间的逻辑关系
> - 线性表：一种抽象数据类型（存储方式分为顺序表/链表），其元素的逻辑结构为线性结构

> 顺序表是有序表。

## 本章内容
- 2.1 线性表的定义
- 2.2 线性表的顺序存储——顺序表及运算实现
- 2.3 线性表的链式存储——链表及运算实现
  - 单链表
  - 双向链表
  - 循环链表
  - 静态链表*
- 2.4 顺序表和链表综合比较

> 重点考察算法思想且对时空复杂度有要求


## 2.1 线性表的定义
线性表为 $n(n>=0)$ 个**相同数据元素**的**有限序列**，其特点为：
存在唯一首元素、尾元素，除首元素和尾元素外，其余每个元素只有一个前驱和后继（线性结构）。

![1683633202131](image/数据结构/1683633202131.png)


## 2.2 顺序表——线性表的顺序存储
用一段**连续的内存空间**存储线性表中的元素。**逻辑上相邻**的元素，**物理存储**位置**也相邻**。
```c
// 静态分配
#define MAXSIZE 100
typedef struct
{
    ElemType elem[MAXSIZE];
    int last; // 最后元素下标
} SeqList;
```

```c
// 动态分配
typedef struct
{
    Elemtype *pElem;
    int last;
    int maxSize;
} SeqList;
```

顺序表上的基本运算
- 查找： `GetData(L,i); Locate(L,e)`
- 插入：插入位置 $1 \le i \le n+1$ 等概率时，平均移动 $n/2$ 个元素；
- 删除：删除位置 $1 \le i \le n$ 等概率时，平均移动 $(n-1)/2$ 个元素；

顺序表的优缺点：
- 优点：存储密度大（为1）；可随机访问元素。
- 缺点：插入、删除需要移动大量元素；需要连续的内存空间；静态内存分配。

> 存储密度 = 存储元素所占用的总空间 / 存储结构所占用的总空间

> 【例】：线性表采用顺序存储中的动态分配空间。当n个空间已满时，可申请再增加分配m个空间。如果申请失败，说明系统没有（n+m）可分配的连续存储空间。

> 在一个长度为n的顺序表中删除第 $i(1 \le i \le n)$ 个元素时，需向前移动（n-i）个元素。

> 在个元素的线性表的数组表示中，时间复杂度为 $O(1)$ 的操作：
> - Ⅰ.访问第 $i(1 \le i \le n)$ 个结点和求第 $i(2 \le i \le n)$个结，点的直接前驱
> - Ⅱ.在最后一个结，点后插入一个新的结点
> - ~~Ⅲ.删除第1个结点~~
> - ~~Ⅳ.在第 $i(1 \le i \le n)$ 个结点后插入一个结点~~

顺序表中的算法设计，可能会涉及到折半查找、快速排序、归并排序以及《算法设计与分析》课程中的一些经典算法。

【例】：有两个非递减有序顺序表LA和LB，编写算法将二者合并为非递增有序顺序表LC。假设LC足够大。
```c
SeqList *mergeAndReverse(SeqList *LA, SeqList *LB)
{
    if (LA == NULL || LB == NULL)
        return NULL;
    SeqList *LC = (SeqList *)malloc(sizeof(SeqList));
    LC->pElem = (Elemtype *)malloc(sizeof(Elemtype) * (LA->last + LB->last + 2));
    LC->last = -1;
    LC->maxSize = LA->last + LB->last + 2;
    int i = LA->last, j = LB->last;
    while (i >= 0 && j >= 0)
        LC->pElem[++LC->last] = LA->pElem[i] >= LB->pElem[j] ? LA->pElem[i--] : LB->pElem[j--];
    while (i >= 0)
        LC->pElem[++LC->last] = LA->pElem[i--];
    while (j >= 0)
        LC->pElem[++LC->last] = LB->pElem[j--];
    return LC;
}
```

【例】：在长度为n的顺序表L中，删除所有值为e的数据元素。要求时间复杂度为 $O(n)$ 、空间复杂度为 $O(1)$ 。
```c
void DeleteItems(SeqList *L, Elemtype e)
{
    if (L == NULL)
        return;
    int k = 0;
    for (int i = 0; i <= L->last; i++)
        if (L->pElem[i] != e)
            L->pElem[k++] = L->pElem[i];
    L->last = k - 1;
}
```
> 一端工作 类似直接插入排序  
> 算法思想：从空序列开始，依次判断每个元素是否为e：若是e，则继续向后判断，若不是e，则将其插入到前面不含e的列表，继续向后判断。直到结束。  
> 不改变原有元素相对先后顺序  

```c
void DeleteItems(SeqList *L, Elemtype e)
{
    if (L == NULL)
        return;
    int i = 0, j = L->last;
    while (i < j)
    {
        while (i < j && L->pElem[i] != e)
            i++;
        while (i < j && L->pElem[j] == e)
            j--;
        if (i < j)
        {
            Elemtype temp = L->pElem[i];
            L->pElem[i] = L->pElem[j];
            L->pElem[j] = temp;
        }
    }
    L->last = j - 1;
}
```
> 两头夹击 类似一趟快速排序  
> 算法思想：从左边找个是e的元素，从右边找一个不是e的元素，将右边不是e的元素移动到左边元素e的位置。直到左右汇合。  
> 会改变原有元素相对顺序  

【例】已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。
```c
void AdjustSqlist(SeqList *L)
{
    if (L == NULL)
        return;
    int i = 0, j = L->last;
    while (i < j)
    {
        while (i < j && L->pElem[i] % 2 != 0)
            i++;
        while (i < j && L->pElem[j] % 2 == 0)
            j--;
        if (i < j)
        {
            Elemtype temp = L->pElem[i];
            L->pElem[i] = L->pElem[j];
            L->pElem[j] = temp;
        }
    }
}
```

【例】：在长度为的有序顺序表L中，删除所有值相等的多余元素，要求保持原有元素的相对位置不变，且时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。
```c
void DeleteRepeatItems(SeqList *L)
{
    if (L == NULL)
        return;
    int i = 0;
    for (int j = 1; j <= L->last; j++)
        if (L->pElem[i] != L->pElem[j])
            L->pElem[++i] = L->pElem[j];
    L->last = i;
}
```
> 算法思想：类似直接插入排序，将第一个元素视为非重复的有序表，然后依次判断后面的元素是否与前面有序表的最后一个元素相同。若相同，则继续向后判断，若不同，则将其插入到前面非重复有序表中。直到结束。

【变形题】：长度为的无序顺序表L存放正整数元素（元素值不大于1000），编写算法，每个元素保留第一次出现的元素，删除重复出现的多余元素，要求时间复杂度为 $O(n)$ 。
```c
void DelrepeatElem(SeqList *L)
{
    if (L == NULL)
        return;
    int *hash = (int *)malloc(sizeof(int) * MAXSIZE);
    memset(hash, 0, sizeof(int) * MAXSIZE);
    int i = 0;
    for (int j = 0; j < L->last; j++)
    {
        if (hash[L->pElem[j]] == 0)
        {
            hash[L->pElem[j]] = 1;
            L->pElem[i++] = L->pElem[j];
        }
    }
    L->last = i - 1;
}
```

【例】顺序表 $L = (a_1, a_2, \ldots, a_n, b_1, b_2, \ldots, b_m)$ ，设计一个算法，将顺序表调整为 $L = (b_1, b_2, \ldots, b_m, a_1, a_2, \ldots, a_n)$ 。
```c
// 反转顺序表[a,b)区间
void Reverse(SeqList *L, int a, int b)
{
    if (L == NULL)
        return;
    for (int i = a; i < (a + b) / 2; i++)
    {
        Elemtype temp = L->pElem[i];
        L->pElem[i] = L->pElem[a + b - 1 - i];
        L->pElem[a + b - 1 - i] = temp;
    }
}

// 转换a1-an ba-bm -> b1-bm a1-an
void ExchangeSqlist(SeqList *L, int n, int m)
{
    if (L == NULL)
        return;
    Reverse(L, 0, n + m); // 反转整个顺序表
    Reverse(L, 0, m); // 反转前m个元素
    Reverse(L, m, n + m); // 反转后n个元素
}
```

【例】求主元素。某顺序表中存放正整数，如果存在一个数，其出现的频率大于50%，则称其为该顺序表的主元素。设计一个算法找出顺序表中的主元素，如果没有则输出-1。要求时间复杂度尽可能低。

算法原理：去掉数组中一个主元素和另一个与主元素不相等的数，剩下的数中，主元素的出现频率仍然大于50%。

算法步骤：
1. 将第一个出现的元素保存到majorNum中，用count记录majorNum出现的次数，初始时令count=1。
2. 如果下一个遇到的元素仍然是majorNum则将count加1，否则将count减1。如果count=0，则将下一个元素保存到majorNum中，并重置count为0。重复该步骤，直至扫描完全部元素。
3. 判断此时的majorNum是否为真正的主元素。统计majorNum出现的次数，并保存到count中，如果count>n/2，则是主元素，否则不是。

代码实现：
```c
int Majority(int A[], int n)
{
    int majorNum = A[0];
    int count = 1;
    for (int i = 1; i < n; i++)
    {
        if (A[i] == majorNum)
            count++;
        else
        {
            if (count > 0)
                count--;
            else
            {
                majorNum = A[i];
                count = 1;
            }
        }
    }
    if (count > 0)
    {
        count = 0;
        for (int i = 0; i < n; i++)
            if (A[i] == majorNum)
                count++;
    }
    return count > n / 2 ? majorNum : -1;
}
```

【例】一个长度为N的整型数组 $A[1..N]$ ，给定正整数X，设计一个尽可能高效的算法，查找这个数组中所有两两之和等于X的整数对。若存在，则输出；否则输出“不存在！”
1. 简述算法思想
2. 用C描述该算法
3. 分析算法的时空复杂度。

> 先用快速排序从小到大排序，再从两端开始枚举。

```c
void pairNum(int a[], int n, int target)
{
    // 快速排序（略）
    int i = 0, j = n - 1, f = 0;
    while (i < j)
    {
        if (a[i] + a[j] == target)
        {
            f = 1;
            printf("%d %d\n", a[i], a[j]);
            i++;
            j--;
            continue;
        }
        a[i] + a[j] < target ? i++ : j--;
    }
    if (!f)
        printf("不存在！\n");
}
```

【例】对于给定的含有n元素的无序序列 $a[1..n]$ ，设计时间复杂度尽可能小的算法，查找这个序列中第k小的元素 $(1 \le k \le n)$ ，并分析你所设计算法的时间复杂度。
- 方法一：对a进行排序，则第k小的元素为 $a[k]$ 。
- 方法二：采用堆排序、冒泡或简单选择排序进行k趟排序。
- 方法三：采用快速排序。

方法三：分治求解——快速排序思想
对于序列 $a[1..n]$ ，在其中查找第k小元素的过程如下：以 $a[q]$ 作为基准元素进行划分，其对应下标为i。三种情况：
![1683684404654](image/数据结构/1683684404654.png)
- 若 $i=k$ ， $a[i]$ 即为所求，返回 $a[i]$ 。
- 若 $i>k$ ，第 $k$ 小的元素应在 $a[1..i-1]$ 子序列中，递归在该子序列中求解第 $k$ 小元素并返回其结果。
- 若 $i<k$ ，第 $k$ 小的元素应在 $a[i+1..n]$ 子序列中，递归在该子序列中求解第 $k-i$ 小并返回其结果。

【2016-408】已知由 $n(n \ge 2)$ 个正整数构成的集合 $A = \{a_k\} \quad (0 \le k \le n)$ ，将其划分为两个不相交的子集 $A_1$ 和 $A_2$ ，元素个数分别是 $n_1$ 和 $n_2$ ， $A_1$ 和 $A_2$ 中元素之和分别为 $S_1$ 和 $S_2$ 。
设计一个尽可能高效的划分算法，满足 $|n_1 - n_2|$ 最小且 $|S_1 - S_2|$ 最大。要求：
1. 给出算法的基本设计思想。
2. 根据设计思想，采用C、C++描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

算法思路：将A递增排序，前 $\left \lfloor n/2 \right \rfloor$ 个元素放在 $A_1$，中，其他放在 $A_2$ 中。实质为查找第 $n/2$ 小元素。
算法步骤：
- 对序列进行一趟快速排序，划分位置为i
- 若 $i = \left \lfloor n/2 \right \rfloor$ ，则划分结束。
- 若 $i < \left \lfloor n/2 \right \rfloor$ ，则枢轴及之前的所有元素均属于 $A_1$ ，继续对 i 之后的元素进行划分。
- 若 $i > \left \lfloor n/2 \right \rfloor$ ，则枢轴及之后的所有元素均属于 $A_2$ ，继续对 i 之前的元素进行划分。

【2020-408】定义三元组 $(a, b, c)$ （$a, b, c$ 均为正数）的距离 $D = |a-b| + |b-c| + |c-a|$ 。给定3个非空整数集合 $S_1, S_2, S_3$ ，按升序分别存储在3个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组 $(a, b, c)$ （其中 $a \in S_1, b \in S_2, c \in S_3$ ）中的最小距离。例如 $S_1 = \{-1, 0, 9\}, S_2 = \{-25, -10, 10, 11\}, S_3 = \{2, 9, 17, 30, 41\}$ ，则最小距离为2，相应的三元组为 $(9, 10, 9)$ 。要求：
1. 给出算法的基本设计思想。
2. 根据设计思想，采用C、C++描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

> 分析。由 $D = |a-b| + |b-c| + |c-a| \ge 0$ 得：
> 1. 当 $a=b=c$ 时，距离最小。
> 2. 其余情况。不失一般性，假设 $a \le b \le c$ ，观察下面的数轴：
>    ![1683709816890](image/数据结构/1683709816890.png)
> 由D的公式可知，决定D大小的是a和c之间的距离，因此，可每次固定c，然后找a，使得 $|c-a|$ 最小。

算法思想：使用三个指针分别指向三个数组的首个元素，每次移动三个指针中指向元素最小的指针（三个指针可能交替移动），移动后检查有没有产生更短的距离。
```c
int min(int a, int b, int c, int i, int j, int k)
{
    if (a <= b && a <= c)
        return i;
    else if (b <= a && b <= c)
        return j;
    else
        return k;
}

int findMinDist(int s1[], int s2[], int s3[], int n1, int n2, int n3)
{
    int min_dist = INT_MAX;
    int dist;
    int i = 0, j = 0, k = 0;

    // T(n) = O(n1+n2+n3)
    while (i < n1 && j < n2 && k < n3) // 当其中一个数组结束后，不存在更小的距离
    {
        dist = abs(s1[i] - s2[j]) + abs(s2[j] - s3[k]) + abs(s3[k] - s1[i]);
        if (dist < min_dist)
            min_dist = dist;
        int x = min(s1[i], s2[j], s3[k], i, j, k); // 返回最小值的下标
        if (x == i)
            i++;
        else if (x == j)
            j++;
        else
            k++;
    }
    printf("%d %d %d\n", s1[i], s2[j], s3[k]);
    return min_dist;
}
```


## 2.3 链表——线性表的非顺序存储
线性中的元素在内存空间中的位置**不一定连续**。为了维系元素的逻辑关系，需要额外的指针域(next)记录下一个元素的位置。
```c
typedef struct Node
{
    ElemType data;
    struct Node *next;
} Node, *LinkList;
```

![1683711030198](image/数据结构/1683711030198.png)
区分：头指针、头结点、首元素结点

> 有头结点的好处：
> 1. 处理第一个结点和处理其他结点操作相同。
> 2. 参数带头指针即可，无需指针的指针。

链表上的基本运算
- 建链表：头插法、尾插法
- 查找： `GetData(L,i); Locate(L,e)`
- 插入：不需要移动元素， $T(n) = O(1)$
- 删除：不需要移动元素， $T(n) = O(1)$

链表的优缺点：
- 优点：插入、删除不需要移动大量元素；动态分配内存。
- 缺点：存储密度小；不能随机访问。

链表分类：
- 单链表 ![1683711181877](image/数据结构/1683711181877.png)
- 循环单链表 ![1683711194156](image/数据结构/1683711194156.png)
- 双向链表 ![1683711203620](image/数据结构/1683711203620.png)
  - 双向链表的插入 ![1683711278389](image/数据结构/1683711278389.png)
  - 双向链表的删除 ![1683711307960](image/数据结构/1683711307960.png)
- 循环双向链表 ![1683711220880](image/数据结构/1683711220880.png)
- 静态链表 ![1683711231124](image/数据结构/1683711231124.png)

【2021-408】已知头指针指向一个带头结点的非空单循环链表，结点结构为 $\left [ data | next \right ]$
![1683711656207](image/数据结构/1683711656207.png)
其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列：
```c
q = h->next;
h->next = q->next;
if (q == p) // 删除的是尾结点
    p = h;
free(q);
```

【2022-408】现有非空双向链表L，其结点结构为 $\left [ prev | data | next \right ]$，其中 prev 是指向直接前驱结点的指针， next 是指向直接后继结点的指针

若要在L中指针p所指向的结点（非尾结点）之后插入指针s指向的新结点，则在执行了语句
```c
s->next = p->next;
p->next = s;
```
后，还要执行：
```c
s->prev = s->next->prev;
s->next->prev = s;
```

【例】链表就地逆置。(头插法)

【例】：假设两个按元素值**递增有序**排列的线性表A和B，均以单链表作为存储结构。编写算法，将A表和B表归并成一个按元素值**递减有序**的排列的线性表C，并要求利用原表（即A表和B表的）结点空间存放表C。(头插法)

【例】：单链表中的元素以值递增有序排列，试写一高效算法，删除表中所有大于mink且小于maxk的元素（ $mink < maxk$ ），算法的时间复杂度 $O(n)$ 。
```c
void DelData(LinkList L, ElemType mink, ElemType maxk)
{
    Node *p = L->next, *pre = L;
    while (p && p->data <= mink) // 找到第一个大于mink的结点
    {
        pre = p;
        p = p->next;
    }
    while (p && p->data < maxk)
    {
        pre->next = p->next;
        free(p);
        p = pre->next;
    }
}
```

【例】：从尾到头输出单链表中每个结点的元素（设为整数）
- 思路一：逆置->从头到尾输出->逆置
- 思路二：设置一个栈；从头到尾依次进栈；逐个出栈并输出
- 思路三：递归
  ```c
  void ReversePrint(LinkList L)
  {
      if (!L) return;
      if (L->next) ReversePrint(L->next);
      printf("%d", L->data);
  }
  ```

【例】：给定一个单向链表，判断它是不是回文链表，要求时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。
- 方法1：先遍历一遍求得中间结点。从头到中间结点，逆置。一个指针从头开始，另一个指针从中间结点后面开始，逐个判断。结束后将前半段逆置恢复。
- 方法2：基于栈

```c
int isPalindrome(LinkList head) {
    if (!head || !head->next) { // 空链表或只有一个结点，视为回文链表
        return 1;
    }
    
    // 快慢指针找到中间结点
    Node *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // 将中间结点之后的结点逆置
    Node *prev = NULL, *cur = slow, *next;
    while (cur) {
        next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    
    // 从头和中间开始比较
    Node *p1 = head, *p2 = prev;
    int res = 1;
    while (p2) {
        if (p1->data != p2->data) {
            res = 0;
            break;
        }
        p1 = p1->next;
        p2 = p2->next;
    }
    
    // 恢复链表并返回结果
    cur = prev, prev = NULL;
    while (cur) {
        next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    slow->next = prev;
    return res;
}
```

【例】：在一个单链表L中，P为中间某结点，在P前插入S结点，可否在 $O(1)$ 时间内完成？
思路：采用交换方式。将S插入在P后面，再交换P与S的值。
![1683718562298](image/数据结构/1683718562298.png)
```c
void insertNode(Node *p, Node *s) {
    s->next = p->next;
    p->next = s;
    ElemType tmp = p->data;
    p->data = s->data;
    s->data = tmp;
}
```

> 可以处理尾结点的插入，如果链表存在头结点，还可以处理首元素的插入。

【例】：给定一个单链表头指针和指向某结点的指针，能否在时间复杂度 $O(1)$ 内删除该结点。
```c
void deleteNode(Node *p) {
    Node *q = p->next;
    p->next = q->next;
    p->data = q->data;
    free(q);
}
```

> 不能，上面的算法无法删除尾节点。（但可以在平均时间复杂度 $O(1)$ 内删除。（对于尾节点单独处理。））

【例】：某链表L，可能是单链表，也可能循环链表（尾元素的指针域可指向链表中的任意一结点），编写算法判断该链表的类型。
```c
int isLoopList(LinkList L)
{
    LinkList slow = L, fast = L;
    while (fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            return 1;
    }
    return 0;
}
```

【例】：已知一个带头结点的单链表L，在不改变链表的前提下，设计一个尽可能有效的算法，查找倒数第k个位置上的结点。
```c
Node *findKthNode(LinkList L, int k)
{
    LinkList slow = L, fast = L;
    while (k--)
        fast = fast->next;
    while (fast)
    {
        slow = slow->next;
        fast = fast->next;
    }
    return slow;
}
```

【例】：某循环单链表（尾元素的指针域可指向链表中的任意一结点），编写算法求循环结点。
![1683719874837](image/数据结构/1683719874837.png)
```c
Node* findLoopNode(LinkList head) {
    if (!head || !head->next) { // 链表为空或只有一个结点，不可能有循环结点
        return NULL;
    }
    
    Node *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { // 快慢指针相遇，说明有循环
            break;
        }
    }
    
    if (!fast || !fast->next) { // fast 到达链表末尾，没有循环
        return NULL;
    }
    
    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    return slow; // 返回循环结点
}
```

【例】：在单链表存储结构上，实现某种排序算法。如直接插入排序，或冒泡排序，或简单选择排序，或一趟快速排序。如，直接插入排序：
```c
void InsertSort(LinkList L)
{
    if (L == NULL || L->next == NULL)
        return NULL;
    Node *p = L->next->next;
    L->next->next = NULL;
    while (p)
    {
        Node *pre = L;
        // 寻找插入位置
        while (pre->next && pre->next->data < p->data)
            pre = pre->next;
        // 插入
        Node *tmp = p->next;
        p->next = pre->next;
        pre->next = p;
        p = tmp;
    }
}
```

【XXXX-408】：判断两个链表是否相交。若相交，求相交点。(变形：两个单词的共同后缀)
![1683720962100](image/数据结构/1683720962100.png)
```c
Node* findFirstCommonNode(LinkList head1, LinkList head2) {
    if (!head1 || !head2)
        return NULL;
    Node *p1 = head1, *p2 = head2;
    while (p1 != p2) {
        p1 = p1 ? p1->next : head2;
        p2 = p2 ? p2->next : head1;
    }
    // 如果没有相交点，p1 和 p2 最后都会指向 NULL
    return p1;
}
```

【2015-408】用单链表保存个整数，结点的结构为： $\left [ data | link \right ]$ ，且 $|data| \le n (n为正整数)$ 。现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head如下：
![1683724491928](image/数据结构/1683724491928.png)
```c
void delSame(LinkList L)
{
    int hash[5001] = {0};
    Node *p = L->next, *pre = L;
    while (p)
    {
        int k = abs(p->data);
        if (hash[k] == 0)
            hash[k] = 1;
        else
        {
            pre->next = p->next;
            free(p);
            p = pre->next;
        }
    }
}
```

【2019-408】设线性表 $L = (a_1, a_2, \cdots, a_{n-1}, a_n)$ 采用带头结点的单链表保存，链表中结点定义如下：
```c
typedef struct node
{
    int data;
    struct node *next;
} Node, *LinkList;
```
请设计一个空间复杂度为 $O(1)$ 且时间上尽可能高效的算法，重新排列 $L$ 中的各结点，得到线性表 $L' = (a_1, a_n, a_2, a_{n-1}, a_3, a_{n-2}, \cdots)$ 。
```c
void specialReverse(LinkList L)
{
    if (L == NULL || L->next == NULL)
        return;
    // 获取中间节点
    Node *mid = L, *fast = L;
    while (fast && fast->next)
    {
        mid = mid->next;
        fast = fast->next->next;
    }
    Node *p = mid->next;

    while (p) // 头插法，就地逆置链表后半段
    {
        Node *tmp = p->next;
        p->next = mid->next;
        mid->next = p;
        p = tmp;
    }
    p = p->next;         // p在前半段，在p节点后面插入
    Node *q = mid->next; // q指向后半段待被移走的节点
    mid->next = NULL;    // 前后链表断开，设置链表尾
    while (q)
    {
        Node *tmp = q->next;
        q->next = p->next;
        p->next = q;
        q = tmp;
        p = p->next->next;
    }
}
```


## 2.4 顺序表和链表的优缺点比较
顺序表：
- 优点：无需存储元素间的关系，存储密度大；可随机查找；
- 缺点：若静态分配，则容易造成溢出或空间浪费，若动态分配，需要移动大量元素；插入删除需要移动大量元素。

链表：
- 优点：动态分配；插入删除不需要移动元素。
- 缺点：需要额外空间存储元素间的关系；不能随机查找。

选择合适存储结构，依据如下：
- 线性表长度是否经常变化；
- 各种操作的频率；
- 操作的位置；

> 某线性表用带头结点的循环单链表存储，头指针为head，当 `head->next->next=head` 成立时，线性表长度可能是 （ 0或1 ）。



# 第3章 栈与队列
线性表
- 受限
  - 操作位置受限：栈、队列
  - 元素类型受限：串
- 扩展：数组、广义表

## 本章内容
栈
- 基本概念
- 存储结构与基本操作
- 栈与递归
- 栈的应用

队列
- 基本概念
- 存储结构与基本操作
- 队列的应用


## 3.1 栈
![1684242708353](image/数据结构/1684242708353.png)
栈特性：先进后出（FILO）或后进先出（LIFO）

n个元素依次进栈，如果进栈和出栈可以交替进行，则出栈元素的排列个数为 Catalan 数： $C_n = \frac{1}{n+1} \binom{2n}{n}$

### 栈的基本操作
```c
InitStack(&S); // 初始化栈
StackEmpty(S); // 判断栈是否为空
Push(&S, x); // 进栈
Pop(&S, &x); // 出栈
GetTop(S, &x); // 取栈顶元素
DestroyStack(&S); // 销毁栈
```

### 1. 顺序栈
![1684242744595](image/数据结构/1684242744595.png)

### 2. 两栈共享
- 初始化： `top[0] = -1; top[1] = MAXSIZE;`
- 栈满： `top[0] + 1 == top[1]`
- 栈空：
  - 1号栈空： `top[0] == -1`
  - 2号栈空： `top[1] == MAXSIZE`
- 进栈：
  - 1号栈： `data[++top[0]] = x;`
  - 2号栈： `data[--top[1]] = x;`

![1684242893055](image/数据结构/1684242893055.png)

### 3. 链栈
![1684242907691](image/数据结构/1684242907691.png)

### 4. 栈与递归
1. 递归的优点：算法简单、结构清晰、正确性容易证明。
2. 递归适合条件：原问题可以层层分解为类似子问题；最小子问题有解；子问题的解可以容易合并为原问题的解。
3. 递归的缺点（为什么要消除递归）：时空效率低；无法得到递归过程的某中间状态。

4. 递归进层：
   1. 保留本层参数与返回地址；（保存断点，进栈）
   2. 为被调函数的局部变量分配存储空间，给下层参数赋值；
   3. 转移到被调函数入口。
5. 递归退层：
   1. 保留被调函数计算结果；
   2. 释放被调函数的数据区，恢复上层参数；（出栈）
   3. 转移到保存的返回地址继续执行。

> 所有的对递归的算法考察都有可能在这里出现。
> 比如：
> - 给一段递归代码，写结果；
> - 用递归算法求解问题。递归与分治求解的经典问题需要掌握。

### 5. 栈的应用
- 进制转换
- 回文判断
- 括号匹配
- 表达式求值
- 中缀转后缀表达式
- 后缀表达式计算

> 符合数据先产生-后处理的情况，一般需要用栈来保存。

> 顺序栈因为是顺序存储，因此可以随机存取第i个元素。（X）

### 习题
假定利用数组 $a[n]$ 顺序存储一个栈，用top表示栈顶指针，用 `top==-1` 表示栈空，并已知栈未满，当元素x进栈时所执行的操作为（ `a[++top]=x` ）。

向一个栈顶指针为top的链栈中插入一个x结点，则执行：
```c
// 带头结点
x->next = top->next;
top->next = x;
// 不带头结点（top为指针的指针）
x->next = top;
top = x;
```

【2022-408】给定有限符号集S，in和out均为S中所有元素的任意排列。对于初始为空的栈ST。
- ~~A. 若in是ST的入栈序列，则不能判断out是否为其可能的出栈序列~~
- ~~B. 若out是ST的出栈序列，则不能判断in是否为其可能的入栈序列~~
- ~~C. 若in是ST的入栈序列，out是对应in的出栈序列，则in与out一定不同~~
- D. 若in是ST的入栈序列，out是对应in的出栈序列，则in与out可能互为倒序

> 若栈的大小受限，会更加复杂

```c
int f(int x)
{
    return ((x > 0) ? x * f(x - 1) : 2);
}
f(f(1)); // 4
```

表达式 $a * (b + c) - d$ 的后缀表达式为（ `a b c + * d -` ）。
- 二叉树的后序遍历
- 操作符栈

【例】对后缀表达式 $a b + a c d + e / f - * - g +$ 进行运算时，用栈来暂存运算数。若栈初始时为空，则运算过程中同时保存在栈中的运算数的最大个数是（ 4 ）。

【例】假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈操作的序列可表示为仅有I和O组成的序列，可以操作的序列称为合法序列。设计一个算法，判定所给的操作序列是否合法。
- 算法基本思想：依次读入字符，若为I，则计数器 `numI++` ；否则 `numO++` ，并判断numO和numI的个数，如果 `numO>numI` ，则返回0，提前结束。字符读取结束后，对numI和numO进行判断，如果 `numI==numO` ，则返回1，否则返回0。

```c
int Judge(int A[])
{
    int numI = 0, numO = 0;
    for (int i = 0; A[i] != '\0'; i++)
        A[i] == 'I' ? numI++ : numO++;
    return numI == numO;
}
```

【例】 $1, 2, \ldots, n$ 依次进栈，进栈和出栈可交替进行，给定一个序列 $p1, p2, \ldots, pn$ ，设计算法判断是否为合理的出栈序列。
```cpp
bool IsLegal(int a[], int n)
{
    stack<int> s;
    for (int i = 0, k = 1; i < n; i++)
    {
        while (a[i] >= k)
            s.push(k++);
        if (a[i] < s.top())
            break;
        if (a[i] == s.top())
            s.pop();
    }
    return s.empty();
}
```

【例】中缀表达式转后缀表达式（逆波兰式）
- 基本思想：初始化栈，'#'入栈。顺序扫描表达式str，重复以下步骤，直到表达式结束：
  - 如果是操作数，直接存入backExp，继续读取字符；
  - 如果是操作符op2，与栈顶操作符op1比较：
    - 若 `op2>op1` ，则op2入栈，继续读取字符；
    - 否则，op1出栈，存入backExp。

```c
char *InfixToPostfix(char *str)
{
    int i = 0, j = 0;
    Stack S;
    char *backExp = (char *)malloc(sizeof(char) * (strlen(str) + 1));
    InitStack(S);
    Push(S, '#');
    while (GetTop(S) != '#' || str[i] != '#')
    {
        if (IsOperand(str[i]))
        {
            backExp[j++] = str[i++];
        }
        else
        {
            op1 = GetTop(S);
            op2 = str[i];
            result = compare(op2, op1);
            if (result == '>')
            {
                Push(&S, op2);
                i++;
            }
            else
            {
                Pop(&S, &op1);
                backExp[j++] = op1;
            }
        }
    }
    backExp[j] = '\0';
    return backExp;
}
```

【例】后缀表达式求值
- 基本思想：初始化栈，顺序扫描后缀表达式str，重复以下步骤，直到表达式结束：
  - 如果是数字，直接入栈；
  - 如果是操作符，取出栈顶两个元素，进行运算，将结果入栈。
            

