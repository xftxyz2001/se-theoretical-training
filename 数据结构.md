# 第0章 课程安排
总成绩 = 20%平时（考勤+课堂表现） + 20%作业（雨课堂完成每章一个测试卷） + 60%考试（闭卷考试）



# 第1章 绪论

## 本章内容
- 1.1 基本概念
  - 数据，数据对象，数据元素，数据项
  - 数据类型（原子、构造、抽象）
  - 数据结构
- 1.2 数据结构三要素：逻辑结构、物理结构与运算
- 1.3 算法及其评价
  - 算法的定义、特性、设计要求
  - 算法评价：时空复杂度


## 1.1 基本概念
- **数据**：能输入计算机且被处理的各种符号的**集合**。
- **数据元素**：组成数据的基本单位，是数据集合的**个体**。本课程讨论的最小单位。
- **数据对象**：性质相同的数据元素的集合，是数据的一个**子集**。
- **数据结构**：带有某种结构关系的、性质相同的数据元素的集合，包括逻辑关系、物理存储和操作。

数据类型
- **原子类型**：值不可再分的数据类型。如 int,char,double 等。
- **结构类型**：值可以再分解为若干成分的数据类型。如 struct、union 。
- **抽象数据类型ADT**：
  - 数组是什么类型？构造
  - 枚举是什么类型？原子
  - 指针是什么类型？原子

**抽象数据类型**（Abstract Data Type）定了一个数据对象、数据对象中各元素间的结构关系和一组操作。可用一个三元组表示：（数据对象、关系、基本操作）

**抽象是一种思维方式**，抽取问题的本质特征，隐藏了复杂的细节，让使用者**只关注应用**而**不关注实现细节**。

> 哥尼斯堡七桥问题：![1683620980738](image/数据结构/1683620980738.png)
> 欧拉回路条件：
> 1. 图形必须是连通的。
> 2. “奇点”个数是0或2。


## 1.2 数据结构三要素
**逻辑结构**：数据元素间的逻辑关系，分为线性结构和非线性结构（集合、树和图结构）。
![1683621076323](image/数据结构/1683621076323.png)

![1683621098417](image/数据结构/1683621098417.png)

> 数据元素及其关系的物理存储方式分**顺序存储**和**链式存储**。该说法（ ）。
> - A 正确
> - B 错误

**物理结构**：数据元素及其关系在计算机上的映像。
- 顺序：存储地址连续
- 非顺序：
  - 链式：存储地址不一定连续
  - 索引：需要另外建立索引表上非顺序
  - 散列：哈希存储

![1683621416115](image/数据结构/1683621416115.png)

**运算（操作）**：施加在数据对象上的一组运算。基于逻辑结构定义，基于存储结构实现。
![1683621458410](image/数据结构/1683621458410.png)

> 以下属于算法特性的是
> - A 正确性
> - B 可读性
> - C 可行性
> - D 健壮性
> - E 确定性
> - F 有限性


## 1.3 算法特性与性能分析
- **算法定义**：解决特定问题的一系列操作。
  ![1683621611566](image/数据结构/1683621611566.png)
- **算法特性**：输入（$\ge 0$）、输出（$\ge 1$）、确定性、可行性和有限性。
- **算法设计要求**：正确、可读性、健壮性（鲁棒性）、高效低存储。
- **算法描述**：自然语言、伪代码、流程图、高级语言等。

**评价算法优劣的标准——时空复杂度**

时间复杂度 $T(n) = O(f(n))$ ：算法的时间耗费度量，与输入数据的规模有关。表示当 $n$ 逐渐增大时，算法运行的时间耗费增长率与 $f(n)$ 增长率相同。

时间复杂度分析步骤：
1. 找算法中的基本语句（执行频率最高）
2. 计算其执行次数，整理成问题规模 $n$ 的函数 $f(n)$
3. 保留最高次幂，作为（渐进）时间复杂度

$O(1) \lt O(\log n) \lt O(n) \lt O(n\log n) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!) \lt O(n^n)$

![1683621834605](image/数据结构/1683621834605.png)

- 快速排序算法： $T(n) = O(n\log n)$
- Dijkstra算法： $T(n) = O(n^2)$
- 最大团算法： $T(n) = O(n 2^n)$

> 假设某计算机运行速度为10亿次/秒运算，那么
> - 10万个数据排序： $10^5 \times \log 10^5 \div 10^9 \approx 1.7 \times 10^6 \div 10^9 = 1.7ms$
> - 1万个顶点求单源最短路径： $(10^4)^2 \div 10^9 = 0.1s$
> - 100个J顶点求最大团： $100 \times 2^{100} \div 10^9 \approx 1.8 \times 10^{21}s \approx 5.7 \times 10^{15}年$

```c
int i = 0, sum = 0;
while (sum < n)
{
    i++;
    sum += i;
}
```
时间复杂度：
1. 基本语句：while
2. 执行次数：设while循环语句执行次数为m，i从1开始递增，最后取值为m，则：
   - $sum = 1 + 2 + \ldots + m = m(m+1)/2$ ，即 $m(m+1)/2 \le n$
3. $T(n) = O(\sqrt{n})$

```c
void mergesort(int a[], int i, int j)
{
    int m;
    if (i < j)
    {
        m = (i + j) / 2;
        mergesort(a, i, m);
        mergesort(a, m + 1, j);
        merge(a, i, j, m); // O(n)
    }
}
```
递归方程：
$$
\begin{aligned}
T(n) =& 2 T(n/2) + n \\
=& 2[2T(n/2^2) + n/2] + n \\
=& 2^2 T(n/2^2) + 2n \\
=& 2^3 T(n/2^3) + 3n \\
... \\
=& 2^k T(n/2^k) + kn \\
=& nO(1) + n \log n = n + n \log n \\
=& O(n \log n)
\end{aligned}
$$

递归算法时间复杂度分析：
- **替换法**：迭代替换
- **主方法**：利用主定理。设 $a \ge 1, b \gt 1$ 为常数， $T(n) = aT(n / b) + f(n)$ ， 则 $T(n)$ 计算如下：
  - 如果函数 $n^{log_b a}$ 比函数 $f(n)$ 大，则 $T(n) = O(n^{log_b a})$
  - 如果函数 $n^{log_b a}$ 和函数 $f(n)$ 相同，则 $T(n) = O(n^{log_b a} \log n)$
  - 如果函数 $n^{log_b a}$ 比函数 $f(n)$ 小，则 $T(n) = O(f(n))$

> ![1683623195227](image/数据结构/1683623195227.png)

当基本语句执行次数与输入数据的顺序有关时，关注**最坏时间复杂度**。
```c
int Find(int a[], int n, int x)
{
    int i = 0;
    while (i < n) // T(n) = O(n)
    {
        if (a[i] == x)
            break;
        i++;
    }
    return i < n ? i : -1;
}
```

空间复杂度 $S(n) = O(f(n))$ ：算法运行时所占用的存储量，包括形参和临时变量所占空间。在对算法进行存储空间分析时，**只考察临时变量所占空间**。

$S(n)=O(1)$ 的含义：常量空间复杂度，表示算法执行时需要的辅助空间与问题规模无关，也称为算法**原地工作**。
```c
long long Fib(int n)
{
    long long *F = (long long *)malloc(sizeof(long long) * (n + 1)); // S(n)=O(n)
    F[0] = F[1] = 1;
    for (int i = 2; i <= n; i++)
        F[i] = F[i - 1] + F[i - 2];
    return F[n];
}
```

```c
long long Fib(int n)
{
    long x = 1, y = 1, t; // S(n)=O(1)
    for (int i = 2; i <= n; i++)
    {
        t = x;
        x = y;
        y = x + t;
    }
    return y;
}
```

```c
int maxelem(int a[], int i, int j)
{
    int mid = (i + j) / 2, max1, max2; // S(n)=O(n)
    if (i < j)
    {
        max1 = maxelem(a, i, mid);
        max2 = maxelem(a, mid + 1, j);
        return max1 > max2 ? max1 : max2;
    }
    else
    {
        return a[i];
    }
}
```

递归算法空间复杂度 = 每层需要的辅助空间 * 递归深度
```c
typedef int RecordType;
/* r数组中，low到mid单元为一有序序列，mid+1到high为另一有序序列，将二者合并为一个新的有序序列，并放入r数组的low到high单元 */
void Merge(RecordType r[], int low, int mid, int high)
{
    int i, j, k;
    RecordType *A = (RecordType *)malloc(sizeof(RecordType) * (high - low + 1));
    i = low;
    j = mid + 1;
    k = 0;
    while (i <= mid && j <= high)
    {
        if (r[i] <= r[j])
        {
            A[k] = r[i];
            i++;
            k++;
        }
        else
        {
            A[k] = r[j];
            j++;
            k++;
        }
    }
    while (i <= mid)
    {
        A[k] = r[i];
        i++;
        k++;
    }
    while (j <= high)
    {
        A[k] = r[j];
        j++;
        k++;
    }
    for (i = low, k = 0; i <= high; i++, k++)
    {
        r[i] = A[k];
    }
    free(A);
}

void MergeSort(RecordType r[], int low, int high)
{
    int mid;
    if (low < high)
    {
        mid = (low + high) / 2;
        MergeSort(r, low, mid);
        MergeSort(r, mid + 1, high);
        Merge(r, low, mid, high);
    }
}
```
空间复杂度 $S(n)$ ：
- Merge算法中，申请了辅助空间A，该空间的大小为high-low+1。最大时为n，用完即释放。
- 算法递归深度为logn，所以还用了logn的栈空间。
- 因此空间复杂度为 $S(n)=O(n+logn)=O(n)$

> 下面说法：
> - ~~Ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间~~
> - Ⅱ.在相同规模 $n$ 下，复杂度为 $O(n)$ 的算法在时间上总是优于复杂度为 $O(2^n)$ 的算法
> - Ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界
> - Ⅳ.同一个算法，实现语言的级别越高，执行效率越低

算法时间复杂度估算-非递归算法
```c
// T(n) = O(n^{1/2})
void add(int n)
{
    int i = 0, s = 0;
    while (s < n)
    {
        i++;
        s += i;
    }
}
```

```c
// T(n) = O(n \log n)
i = 1;
while (i < n)
{
    for (j = 1; j <= n; j++)
        x += 1;
    i *= 2;
}
```

```c
// T(n) = O(n \log n)
count = 0;
for (k = 1; k <= n; k *= 2)
    for (j = 1; j <= n; j++)
        count++;
```

```c
// T(n) = O(n^{1/2})
int i = 0, sum = 0;
while (sum < n)
    sum += ++i;
return i;
```

```c
// T(n) = O(n)
i = 1;
j = 0;
while (i + j <= n)
    i > j ? j++ : i++;
```

算法时间复杂度估算-递归算法
```c
// T(n) = O(n^2)
void hanoi(int n, char a, char b, char c)
{
    if (n == 1)
    {
        move(a, 1, c);
    }
    else
    {
        hanoi(n - 1, a, c, b);
        move(a, n, c);
        hanoi(n - 1, b, a, c);
    }
}
```

```c
// T(n) = O(n)
void PreOrder(BinTree T)
{
    if (T)
    {
        visit(T);
        PreOrder(T->Left);
        PreOrder(T->Right);
    }
}
```

```c
// T(n) = O(n)
int sum = 0;
for (int i = 1; i < n; i *= 2)
    for (int j = 0; j < i; j++)
        sum++;
```
![1683625533812](image/数据结构/1683625533812.png)

```c
// T(n) = O(n^{1/2}) (n>=0)
while (n >= (x + 1) * (x + 1))
    x++;
```


## 缺失的第一个正数
给定一个含 n（`n>=1`）个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 `{-5, 3, 2, 3}` 中未出现的最小正整数是 1；数组 `{1, 2, 3}` 中未出现的最小正整数是 4。

要求：
1. 给出算法的基本设计思想。
2. 根据设计思想，采用C或C+语言描述算法，关键之处给出注释。
3. 说明你所设计算法的时间复杂度和空间复杂度。

![1683626360132](image/数据结构/1683626360132.png)
![1683626382412](image/数据结构/1683626382412.png)
![1683626395344](image/数据结构/1683626395344.png)

- [leetcode-41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
